#! /bin/bash

# fun: pkg::update::archlinux
# txt: update packages database in the machine
# env: NOCACHE: if true do not cache results, so update will be performed on
#               every call.
pkg::update::archlinux () {
  std::mute pacman -Sy --noconfirm &&
    out::info "updated package database" ||
    err::trace "Unable to update package database"
  ${NOCACHE:-false} || pkg__update__archlinux=true
}
declare pkg__update__archlinux=false

# fun: pkg::exists::archlinux
# txt: implements pkg::exists for archlinux OS provider.
pkg::exists::archlinux () {
  std::mute pacman -Q "$1"
}

# fun: pkg::present::archlinux
# txt: implements pkg::present for archlinux OS provider.
pkg::present::archlinux () {
  if ! pkg::exists::archlinux "$1"; then
    pkg::create::archlinux "$1" &&
      out::info "created package: $1" && return 0 ||
      err::trace "Unable to create package: $1"
    return 1
  fi
  return 0
}

# fun: pkg::absent::archlinux
# txt: implements pkg::absent for archlinux OS provider.
pkg::absent::archlinux () {
  if pkg::exists::archlinux "$1"; then
    pkg::destroy::archlinux "$1" &&
      out::info "destroyed package: $1" && return 0 ||
      err::trace "Unable to destroy package: $1"
    return 1
  fi
  return 0
}

# fun: pkg::create::archlinux
# txt: implements pkg::create for archlinux OS provider.
pkg::create::archlinux () {
  ${pkg__update__archlinux:-false} || pkg::update::archlinux
  std::mute pacman -S --noconfirm "$1"
}

# fun: pkg::destroy::archlinux
# txt: implements pkg::create for archlinux OS provider.
pkg::destroy::archlinux () {
  std::mute pacman -R --noconfirm "$1"
}
