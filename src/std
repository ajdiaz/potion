#! /bin/bash
# mod: std
# txt: The ``std`` module contains standard functions to work with potion.

# fun: std::quit
# txt: perform an exit clean of potion.
std::quit () {
  for handler in ${std__quit_handler[@]}; do
    $handler
  done
}

# fun: std::add_quit_handler <func_name>
# txt: add func_name as handler to execute before quit potion.
declare -A std__quit_handler
std__quit_handler["tmp"]="tmp::destroy"
std::add_quit_handler () {
  std__quit_handler["$1"]="$2"
}
trap std::quit EXIT
trap std::quit CHLD

# fun: std::hmac <text>
# txt: calculate HMAC using SHA1 by default
# env: ALGO: set the algorithm to use for calculate HMAC. Valid values are:
#      sha1, md5, sha256, sha512. The proper helper tool must be installed
#      on the system.
std::hmac () {
  ALGO="${ALGO:=sha1}"
  local sum=
  local path="$(os::path ${ALGO}sum)"
  if [ "$path" ]; then
    sum="$(echo -n "$1" | ${ALGO}sum)"
    read sum _ <<<"$sum"
    echo "$sum"
  else
    err::trace "Required binary '${ALGO}sum' not found"
  fi
}

# fun: std::mute <command/alias/function>
# txt: mute outputs when running a command, alias or function, including
#      mute stderr.
std::mute () {
  "$@" >/dev/null 2>/dev/null
}

# fun: std::strin <str1> <str2>
# txt: return true if str1 is into str2, or false otherwise.
std::strin () {
  [ "${1//$2/}" != "${1}" ]
}

# fun: std::sleep <seconds>
# txt: sleep for specified number of seconds. This function is pure-bash, so
#      not need sleep(1) command.
std::sleep () {
  read -N 0 -t "$1" -s -r </dev/tty 3<&- 3<&0 <&3
}

# fun: std::func <func_name>
# txt: return true if function name passed as argument is defined, or false
#      otherwise.
std::func () {
  std::mute declare -f "$1"
}

# fun: std::arch
# txt: print to stout the hardware architecture of the current host.
std::arch () {
  uname -m
}

# fun: std::os::family
# txt: print to stdout the operating system family
std::os::family () {
  uname -o
}

# fun: std::os::provider
# txt: return the operating system provider (formerly distribution).
std::os::provider () {
  for f in ${std__os__provider[@]}; do
    if [ -r "$f" ]; then
      echo "${std__os__provider["$f"]}"
      return 0
    fi
  done

  if [ -r /etc/lsb-release ]; then
    std::mute grep 'DISTRIB_ID=Ubuntu' /etc/lsb-release &&
      echo ubuntu && return 0
  fi
  return 1
}

declare -A std__os__provider
std__os__provider["/etc/arch-release"]="archlinux"

# fun: std::timestamp
# txt: return the UNIX timestamp
std::timestamp () {
  date +%s
}

# fun: std::parse <arg string>
# txt: parse an argument string in the form key=value and promote this
#      variables to environment.
std::parse () {
  local hasname=false
  local fst="$1"; shift

  [ "${fst#name=}" != "${fst}" ] || fst="name=$fst"

  for arg in "$fst" "$@"; do
    std::strin "$arg" "=" || err::trace "Invalid argument: $arg"
    [ "${arg#name=}" != "${arg}" ] && hasname=true
    echo -n "local ${arg/=/=\'}';"
  done
  ${hasname} || err::trace "The parameter 'name' is mandatory"
  shift
  echo
}

# fun: std::run <command>
# txt: Run command passed as argument if $PRETEND is not set to true
# env: PRETEND: if true do nothing.
std::run () {
  ${PRETEND:-false} || "$@"
}

# fun: std::installed <command>
# txt: return true if command is installed in path
std::installed () {
  std::mute type -p "$1"
}

# fun: std::is_dir_empty <dir>
# txt: return true if dir is empty
std::is_dir_empty () {
  for f in $1/*; do
    [ "$f" == "$1/*" ] && return 0
    return 1
  done
}
