#! /bin/bash
# mod: res
# txt: The ``res`` module provides a way to work with potion resources.

res::variables () {
  for word in "$@"; do
    case "$word" in
      *=*) echo -n "${COLOR_BOLD}${word%%=*}${COLOR_NONE}"
           echo -n "${C}=${word#*=}${COLOR_NONE} ";;
      *) echo -n "$word "
    esac
  done
  echo
}

res::created () {
  if ${VERBOSE:-false}; then
    local mod="$1"; shift
    printf -v _m "%-12s %-10s %-8s %s" \
      "${CONTEXT}" \
      "${COLOR_BOLD}CREATED${COLOR_NONE}" \
      "$mod" \
      "$*"
    out::user "${_m}"
  fi
  out::info "created $1: $(C="$COLOR_INFO" res::variables "$2")"
}

res::deleted () {
  if ${VERBOSE:-false}; then
    local mod="$1"; shift
    printf -v _m "%-12s %-10s %-8s %s" \
      "${CONTEXT}" \
      "${COLOR_BOLD}DELETED${COLOR_NONE}" \
      "$mod" \
      "$*"
    out::user "${_m}"
  fi
  out::warn "deleted $1: $(C="$COLOR_WARN" res::variables "$2")"
}

res::refreshed () {
  if ${VERBOSE:-false}; then
    local mod="$1"; shift
    printf -v _m "%-12s %-10s %-8s %s" \
      "${CONTEXT}" \
      "${COLOR_BOLD}REFRESH${COLOR_NONE}" \
      "$mod" \
      "$*"
    out::user "${_m}"
  fi
  out::info "refreshed $1: $(C="$COLOR_INFO" res::variables "$2")"
}
#! /bin/bash
# mod: context
# txt: This internal module provides functionality to run different context
#      in paralell.

alias context=function

declare -A __context__task
# fun: context::task::enqueue <fun>
# txt: enqueue a task to be done when context finished.
context::task::enqueue () {
  if ! std::strin "${__context__task["${CONTEXT}"]}" ",$1,"; then
    __context__task["${CONTEXT}"]+=",$1,"
  fi
}

# fun: context::task::apply <context>
# txt: apply functions enqueued by context::task::enqueue.
context::task::apply () {
  task="${__context__task["${1}"]}"
  if [ "$task" ]; then
    export IFS=,
    for t in $task; do
      [ "$t" ] || continue
      eval "${t}" || err::trace "Unable to apply post-context task: $t ($CONTEXT)"
    done
  fi
}

# fun: context::execute <name>
# txt: Execute a context named as name.
# env: CONTEXT: contains the context name, and this variable will be
#      propagated to other functions in the same context.
context::execute () {
  export CONTEXT="$1" && $1 && context::task::apply "$1"
}

# fun: context::run
# txt: run all context in paralell.
context::run () {
  local tim cctx=0

  tim="$(std::timestamp)"
  # shellcheck disable=SC2015
  [ "$POTION_COMPILED" ] && local kind="compiled" || local kind="in-line"
  while read -r _ _ context; do
    ((cctx++))
  done < <(declare -F | grep '^declare -f @')

  out::user "found ${cctx} contexts"
  # shellcheck disable=SC2015
  ${PRETEND:-false} &&
    out::info "Starting $kind potion execution (pretending)" ||
    out::info "Starting $kind potion execution"

  while read -r _ _ context; do
    context::execute "$context" &
    ${ONETHREAD:-false} && wait
  done < <(declare -F | grep '^declare -f @')
  wait
  context::task::apply "main"
  tim="$(( $(std::timestamp) - tim ))"
  out::info "Finished potion exection in ${tim} seconds."
}
#!/bin/bash
# mod: include
# txt: The `include` module allows you to include other potions from remote
#      sites.

# fun: include <url>
# api: potion
# txt: include a potion from URL, git repo or file.
include ()
{
  local url=
  case "$1" in
    git://*|ssh+git://*)
      url="${1/ssh+git:/ssh:}"
      tmp::create origin
      out::info $"Cloning remote potion spells from: ${url}..."
      std::mute git clone --depth 1 "$url" . ||
        err::trace $"Unable to clone repository: $url"
      [[ -r ./init.potion ]] ||
        err::trace $"Cloned repository does not provide init.potion file"
      curl::source ./init.potion ||
        err::trace $"Unable to load init.potion file"
      tmp::exit
      ;;
    *)
      curl::source "$1"
      ;;
  esac
}
#! /bin/bash
# mod: host
# api: potion
# txt: The `host` module provides functions to configure hostname of the
#      machine.
# use: host::present myhost.mydomain.com

# fun: host::exists [name=]<hostname>
# api: potion
# txt: return true if the FQDN of the node is equal to specified one.
host::exists () {
  eval $(std::parse "$@")
  local host="$(hostname -f 2>/dev/null)"
  [ "$host" == "$name" ]
}

# private host::_create <hostname>
host::_create () {
  if ! ${PRETEND:-false}; then
    echo "${1%%.*}" > /etc/hostname
    echo "127.0.1.1 $1 ${1%%.*}" > /etc/hosts
    hostname "${1%%.*}"
  fi
}

# private host::_destroy <hostname>
host::_destroy () {
  if ! ${PRETEND:-false}; then
    local hosts="$(grep -v "^127.0.1.1 $1 ${1%%.*}" /etc/hosts)"
    echo > /etc/hostname
    echo "$hosts" > /etc/hosts
    hostname ''
  fi
}

# fun: host::present [name=]<hostname>
# api: potion
# txt: ensure than the node has the specified hostname.
host::present () {
  eval $(std::parse "$@")
  if ! host::exists "$name"; then
    host::_create "$name" &&
      res::created host "$name" ||
      err::trace "Unable to create host to: $1"
  else
    return 1
  fi
}

# fun: host::absent [name=]<hostname>
# api: potion
# txt: ensure than the node has not the specified hostname.
host::absent () {
  eval $(std::parse "$@")
  if host::exists "$name"; then
    host::_destroy "$name" &&
      res::deleted host "$name" ||
      err::trace "Unable to destroy host: $1"
  else
    return 1
  fi
}
#! /bin/bash
# mod: group
# api: potion
# txt: The `group` module offers a way to ensure that specified group of
#      uses is created or not in the system.
# use: group::present mygroup

# fun: group::exists [name=]<groupname>
# api: potion
# txt: return true or false if the specific groupname exists or not,
#      respectively.
group::exists () {
  eval $(std::parse "$@")
  std::mute grep "^$name" /etc/group
}

# private group::_create <groupname> [password]
# create specific groupname passed as argument.
# GROUP_SYSTEM: if true create system group (false by default).
# GROUP_GID: if set, try to use as GID for the group.
group::_create () {
  local ua_opts=""
  local ua_opts+="${GROUP_SYSTEM:+-r }"
  local ua_opts+="${GROUP_GID:+-g ${GROUP_GID} }"
  std::run groupadd $ua_opts "$1"
}

# private group::_destroy <groupname>
# destroy the groupname passed as argument.
group::_destroy () {
  std::run groupdel "$1"
}


# fun: group::present [name=]<groupname> system=<true|false> [gid=gid]
# api: potion
# txt: create group if not exists
# opt: name: the name of the group to create.
# opt: system: if true create a system group.
# opt: gid: the GID of the new group
group::present () {
  eval $(std::parse "$@")
  if ! group::exists "$name"; then
    GROUP_SYSTEM="${system}" \
    GROUP_GID="${gid}" \
    group::_create "$name" &&
      res::created group "$name" "system=${system}" "gid=${gid}" ||
      err::trace "Unable to create group: $name"
  else
    return 1
  fi
}

# fun: group::absent [name=]<groupname>
# api: potion
# txt: destroy groupname if exists
group::absent () {
  eval $(std::parse "$@")
  if group::exists "$name"; then
    group::_destroy "$name" &&
      res::deleted group "$name" ||
      err:trace "Unable to destroy group: $name"
  else
    return 1
  fi
}
#! /bin/bash
# mod: tz
# api: potion
# txt: The `tz` module provides functions to configure timezone in the
#      system.
# env: TZ_DIR: path where zoneinfo live. By default `/usr/share/zoneinfo`.
# use: tz::present Europe/Madrid

TZ_DIR="/usr/share/zoneinfo"

# fun: tz::exists [name=]<zonename>
# api: potion
# txt: if timezone especified in argument is set return true, otherwise
#      return false.
tz::exists () {
  [ -r /etc/localtime ] || return 1

  eval $(std::parse "$@")
  local current="$(file::_hmac file:///etc/localtime)"
  local decided="$(file::_hmac file:///usr/share/zoneinfo/$name)"

  [ "$current" == "$decided" ]  
}

# fun: tz::present [name=]<zonename>
# api: potion
# txt: ensure that specified timezone is set.
tz::present () {
  eval $(std::parse "$@")

  if ! tz::exists "$name"; then
    std::mute std::run ln -sf "${TZ_DIR}/$name" /etc/localtime &&
      res::created tz "$name" ||
      err::trace "Unable to create tz: $name"
  else
    return 1
  fi
}

# fun: tz::absent [name=]<zonename>
# api: potion
# txt: ensure that the specified timezone is not set.
tz::absent () {
  eval $(std::parse "$@")

  if tz::exists "$name"; then
    std::mute std::run rm -f /etc/localtime &&
      res::deleted tz "$name" ||
      err::trace "Unable to destroy tz: $name"
  else
    return 1
  fi
}
#! /bin/bash
# mod: srv
# api: potion
# txt: The `srv` module provides high-level functions to manage package
#      installations.
# use: srv::present sshd

# private srv::sysinit
srv::_sysinit () {
  local si="$(cache::get _sysinit)"
  [ "$si" ] && echo "$si" && return 0

  if std::mute os::path systemctl; then
    local si=systemd
  elif std::mute os::path service; then
    local si=upstart
  elif std::mute os::patch initctl; then
    local si=sysv
  else
    return 1
  fi
  cache::put _sysinit "$si"
  echo "$si"
  return 0
}

# fun: srv::exists [name=]<service>
# api: potion
# txt: return true if the specific service is present in the system.
srv::exists () {
  eval $(std::parse "$@")
  local si="$(srv::_sysinit)"

  if std::func srv::exists::_${si}; then
    srv::exists::_${si} "$name"
  else
    err::trace "Potion does not support '$si' service control... yet"
  fi
}

# fun: srv::present [name=]<service>
# api: potion
# txt: ensure that specified service is installed on the system.
srv::present () {
  eval $(std::parse "$@")
  local si="$(srv::_sysinit)"

  if std::func srv::present::_${si}; then
    srv::present::_${si} "$name"
  else
    err::trace "Potion does not support '$si' service control... yet"
  fi
}

# fun: srv::absent [name=]<service>
# api: potion
# txt: ensure that specified service is not present on the system.
srv::absent () {
  eval $(std::parse "$@")
  local si="$(srv::_sysinit)"

  if std::func srv::absent::_${si}; then
    srv::absent::_${si} "$name"
  else
    err::trace "Potion does not support '$si' service control... yet"
  fi
}

# internal srv::refresh
srv::refresh () {
  eval $(std::parse "$@")
  local si="$(srv::_sysinit)"

  if std::func srv::refresh::_${si}; then
    srv::refresh::_${si} "$name"
  else
    err::trace "Potion does not support '$si' service control... yet"
  fi
}
#! /bin/bash
# mod: srv.systemd
# txt: The ``srv.systemd`` module contains specific functions to configure
#      services with systemd.

# private srv::exists::_systemd
srv::exists::_systemd () {
  std::mute systemctl is-active "${1}"
}

# private srv::present::_systemd
srv::present::_systemd () {
  if ! srv::exists::_systemd "$1"; then
    context::task::enqueue "srv::create::_systemd '$1'"
  fi
}

# private srv::absent::systemd
srv::absent::_systemd () {
  if srv::exists::_systemd "$1"; then
    context::task::enqueue "srv::destroy::_systemd '$1'"
  fi
}

# private srv::create::_systemd
srv::create::_systemd () {
  std::mute std::run systemctl enable "${1}" ||
    err::trace "Unable to enable service: $1"
  std::mute std::run systemctl start "${1}" ||
    err::trace "Unable to start service: $1"
  res::created srv "$1" engine=systemd
}

# private srv::destroy::_systemd
srv::destroy::_systemd () {
  std::mute std::run systemctl stop "${1}" ||
    err::trace "Unable to stop service: $1"
  std::mute std::run systemctl disable "${1}" ||
    err::trace "Unable to disable service: $1"
  res::deleted srv "$1" engine=systemd
}

# private srv::refresh::_systemd
srv::refresh::_systemd () {
  std::mute std::run systemctl restart "$1" ||
    err::trace "Unable to refresh service: $1"
}
#! /bin/bash
# mod: srv.upstart
# txt: The ``srv.upstart`` contains specific functions to create and
#      configure services in upstart based systems.

# private srv::exists::upstart <service>
srv::exists::_upstart () {
  std::mute service "$1" status
}

# private srv::present::_upstart
srv::present::_upstart () {
  if ! srv::exists::_upstart "$1"; then
    context::task::enqueue "srv::create::_upstart '$1'"
  fi
}

# private srv::absent::_upstart
srv::absent::_upstart () {
  if srv::exists::_upstart "$1"; then
    context::task::enqueue "srv::destroy::_upstart '$1'"
  fi
}

# private srv::create::_upstart
srv::create::_upstart () {
  std::mute std::run update-rc.d "${1}" defaults ||
    err::trace "Unable to enable service: $1"
  std::mute std::run service "${1}" start ||
    err::trace "Unable to start service: $1"
  res::created srv "$1" engine=upstart
}

# private srv::destroy::_upstart
srv::destroy::_upstart () {
  std::mute std::run service "$1" stop ||
    err::trace "Unable to stop service: $1"
  std::mute std::run update-rc.d -f "${1}" remove ||
    err::trace "Unable to disable service: $1"
  res::deleted srv "$1" engine=upstart
}

# private srv::refresh::_upstart
srv::refresh::_upstart () {
  std::mute std::run service "$1" restart ||
    err::trace "Unable to refresh service: $1"
}
#! /bin/bash
# mod: swap
# api: potion
# txt: The `swap` module contains functions to create and configure swap
#      space.
# use: swap::present \\
#        /tmp/swapfile \\
#        size=1G \\
#        format=true

# fun: swap::exists
# api: potion
# txt: return true if swap is enabled
swap::exists () {
  read _ swap _ < <(free | grep '^Swap:')
  [ "$swap" != "0" ]
}


# private swap::_create <device|file> <size>
swap::_create () {
  [ -b "$1" ] && local isdevice=true || local isdevice=false

  if ${SWAP_FORMAT:-false}; then
    if ${isdevice:-false}; then
      std::mute blkid "$1" ||
        std::mute mkswap "$1" ||
        err::trace "Unable to make swap for device: $1"
    else
      [ -r "$1" ] ||
        std::mute std::run dd if=/dev/zero of=$1 count=$2 bs=1M &&
          std::mute std::run mkswap "$1" && std::run chmod 0660 "$1" ||
          err::trace "Unable to make swap for file: $1"
    fi
  fi
  std::mute std::run swapon "$1"
}

# private swap::_destroy <device|file>
swap::_destroy () {
  std::mute std::run swapoff "$1"
}

# fun: swap::present [name=<device|file>] [size=<size>] [format=<true|false>]
# api: potion
# txt: ensure that swap is enable in specified device or file and specified
#      size.
# opt: name: the device use as swap space.
# opt: size: the size required if swap file is created
# opt: format: if true, format swap space.
swap::present () {
  eval $(std::parse "$@")
  if ! swap::exists; then
    SWAP_FORMAT=${format:-false} swap::_create "$name" ${size:-0} &&
      res::created swap "$name" "size=$size" ||
      err::trace "Unable to create swap: $name"
  else
    return 1
  fi
}

# fun: swap::absent [name=]<device|file>
# api: potion
# txt: ensure that specified device is not enabled for swap
# opt: name: the device use as swap space.
swap::absent () {
  eval $(std::parse "$@")
  if swap::exists; then
    swap::_destroy "$name" &&
      res::deleted "$name" ||
      err::trace "Unable to destroy swap: $1"
  else
    return 1
  fi
}
#! /bin/bash
# mod: pkg.ubuntu
# txt: The ``pkg.ubuntu`` module contains specific functions to install or
#      remove packages in ubuntu based distributions.
pkg__ubuntu__aptopts='-q --yes '

# private pkg::_update::ubuntu
pkg::_update::ubuntu () {
  DEBIAN_FRONTEND=noninteractive \
    mutex::run pkg_ubuntu std::mute \
      std::run apt-get ${pkg__ubuntu__aptopts} update &&
        out::user "updated package database" ||
        err::trace "Unable to update package database"
  local ret=$?
  if ! ${NOCACHE:-false}; then
    tmp::create _pkg_cache
    : > pkg_update_ubuntu
    tmp::exit
  fi
  return $ret
}

# private pkg::_exists::ubuntu <package>
pkg::_exists::ubuntu () {
  mutex::run pkg_ubuntu dpkg -l | std::mute egrep "^ii\\s+*$1\\s+[^-]*"
}

# private pkg::_present::ubuntu <package>
pkg::_present::ubuntu () {
  if ! pkg::_exists::ubuntu "$1"; then
    pkg::_create::ubuntu "$1" &&
      res::created pkg "$1" ||
      err::trace "Unable to create package: $1"
  else
    return 1
  fi
}

# private pkg::_absent::ubuntu <package>
pkg::absent::ubuntu () {
  if pkg::_exists::ubuntu "$1"; then
    pkg::_destroy::ubuntu "$1" &&
      res::deleted pkg "$1" ||
      err::trace "Unable to destroy package: $1"
  else
    return 1
  fi
}

# private pkg::_create::ubuntu <package>
pkg::_create::ubuntu () {
  tmp::exists pkg_update_ubuntu || pkg::_update::ubuntu
  DEBIAN_FRONTEND=noninteractive mutex::run pkg_ubuntu std::run std::mute \
    apt-get ${pkg__ubuntu__aptopts} install "$1"
}

# private pkg::_destroy::ubuntu <package>
pkg::_destroy::ubuntu () {
  DEBIAN_FRONTEND=noninteractive mutex::run pkg_ubuntu std::run std::mute \
    apt-get ${pkg__ubuntu__aptopts} purge "$1"
}
#! /bin/bash
# vim: ft=sh:
# mod: fstab
# txt: The `fstab` module provides functions to add entries to fstab file.
# use: fstab::present /dev/sda1 \\
#        mount=/ \\
#        fstype=xfs \\
#        opts=default,noauto \\
#        remount=true

# fun: fstab::exists [name=]<device>
# api: potion
# txt: return true if device is set in fstab
fstab::exists () {
  eval $(std::parse "$@")
  std::mute grep -q "^$name" /etc/fstab
}

# private fstab::_create <device> <mntpoint> <type> [options] [dump] [pass]
fstab::_create () {
  eval $(std::parse "$@")
  [ "$mount" ] || err::trace "fstab require mount parameter"
  ${PRETEND:-false} || 
    echo "$name $mount ${fstype:-auto} ${opts:-defaults}" \
         "${dump:-1} ${pass:-2}" >> /etc/fstab

  ${FSTAB_REMOUNT:-false} && std::run mount -oremount,${opts} "$mount" || true
  ${FSTAB_MOUNT:-false} && std::run mount "$mount" || true
}

# private fstab::_destroy <device>
fstab::_destroy () {
  local fstab="$(grep -v "^$1" /etc/fstab)"
  ${PRETEND:-false} || echo "$fstab" > /etc/fstab
}

# fun: fstab::present [name=]<device> mount=<mountpoint> [options]
# api: potion
# txt: ensure that fstab entry for device is present
# opt: name: the device name to ensure
# opt: mount: the mountpoint for the device
# opt: fstype: the fstype of the device filesystem (default: auto)
# opt: opts: mount options (default: defaults)
# opt: dump: the dump number (default 0)
# opt: pass: the pass number (default 1)
# opt: remount: if true remount device when added to fstab
fstab::present () {
  if ! fstab::exists "$@"; then
    FSTAB_REMOUNT="$remount" \
      fstab::_create "$@" &&
        res::created fstab "$@" ||
        err::trace "Unable to create fstab for device: $@"
  else
    return 1
  fi
}

# fun: fstab::absent [name=]<device>
# api: potion
# txt: ensure that specified device has not entry in fstab
fstab::absent () {
  eval $(std::parse "$@")
  if fstab::exists "$name"; then
    fstab::_destroy "$name" &&
      res::deleted fstab "device=$name" ||
      err::trace "Unable to destroy fstab for device: $1"
  else
    return 1
  fi
}
#! /bin/bash
# mod: dir
# api: potion
# txt: The `dir` module provides functions to ensure that specified
#      directory is created or destroyed.
# use: dir::present "/mnt" mode=755

# private dir::_create <dname> [owner] [mode]
dir::_create () {
  std::run mkdir -p "$1" &&
    std::run chown "${2:-0:0}" "$1" &&
    std::run chmod "${3:-755}" "$1"
}

# private dir::_destroy <dname>
dir::_destroy () {
  std::run rm -rf "$1"
}

# fun: dir::present [name=]<name> [options]
# api: potion
# txt: ensure that specified directory name passed as argument exists, and
#      create it if not.
# opt: name: the name of the directory to be created.
# opt: mode: the octal mode of the new directory (755) by default.
# opt: user: the user owner the directory (root by default).
# opt: group: the group owner the directory (root by default)
dir::present () {
  eval $(std::parse "$@")
  if ! dir::exists "$name"; then
    dir::_create "$name" "${user:-0}:${group:-0}" "${mode:-755}" &&
      res::created dir "name=$name user=${user:-0} " \
        "group=${group:-0} mode=${mode:-755}" ||
      err::trace "Unable to create dir: $name"
  else
    return 1
  fi
}

# fun: dir::absent [name=]<name>
# api: potion
# txt: ensure that directory named as arguement, does not exist, removing it
#      if necessary.
# opt: name: the name of the directory to be removed
dir::absent () {
  eval $(std::parse "$@")
  if dir::exists "$name"; then
    dir::_destroy "$name" &&
      res::deleted dir "name=$name" ||
      err::trace "Unable to destroy dir: $name"
  else
    return 1
  fi
}

# fun: dir::exists [name=<fname>]
# api: potion
# txt: return true if directory name passed as argument exists, or false
#      otherwise.
dir::exists () {
  eval $(std::parse "$@")
  [ -d "$name" ]
}
#! /bin/bash
# mod: srv.sysv
# txt: The ``srv.sysv`` module contains specific functions to create and
#      configure services in systemv init environments.

# private srv::exists::_sysv
srv::exists::_sysv () {
  std::mute /etc/init.d/"${1}" status
}

# private srv::present::_sysv
srv::present::_sysv () {
  if ! srv::exists::_sysv "$1"; then
    context::task::enqueue "srv::create::_sysv '$1'"
  fi
}

# private srv::absent::_sysv
# txt: implements srv::absent for sysv provider.
srv::absent::_sysv () {
  if srv::exists::_sysv "$1"; then
    context::task::enqueue "srv::destroy::_sysv '$1'"
  fi
}

# private srv::create::sysv
srv::create::_sysv () {
  std::mute std::run ln -s "/etc/init.d/$1" "/etc/rc3.d/S20-$1" ||
    err::trace "Unable to enable service: $1"
  std::mute std::run "/etc/init.d/$1" start ||
    err::trace "Unable to start service: $1"
  res::created srv "$1" engine=sysv
}

# private srv::destroy::_sysv
srv::destroy::_sysv () {
  std::mute std::run rm -f "/etc/rc3.d/S20-${1}" ||
    err::trace "Unable to disable service: $1"
  std::mute std::run "/etc/init.d/${1}" stop
    err::trace "Unable to stop service: $1"
  res::deleted srv "$1" engine=sysv
}

# private srv::refresh::_sysv
srv::refresh::_sysv () {
  std::mute std::run "/etc/init.d/$1" restart ||
    err::trace "Unable to refresh service: $1"
}
#! /bin/bash
# mod: pkg.archlinux
# txt: The ``pkg.archlinux`` module contains specific functions to install
#      or remove packages in archlinux distribution.

# private pkg::_update::archlinux
pkg::_update::archlinux () {
  mutex::run pkg_archlinux std::run std::mute pacman -Sy --noconfirm &&
    out::user "updated package database" ||
    err::trace "Unable to update package database"
  if ! ${NOCACHE:-false}; then
    tmp::touch pkg_update_archlinux
  fi
}

# private pkg::_exists::archlinux <package>
pkg::_exists::archlinux () {
  mutex::run pkg_archlinux std::mute pacman -Q "$1"
}

# private pkg::_present::archlinux <package>
pkg::_present::archlinux () {
  if ! pkg::_exists::archlinux "$1"; then
    pkg::_create::archlinux "$1" &&
      res::created pkg "$1" ||
      err::trace "Unable to create package: $1"
  else
    return 1
  fi
}

# private pkg::_absent::archlinux <package>
pkg::_absent::archlinux () {
  if pkg::_exists::archlinux "$1"; then
    pkg::_destroy::archlinux "$1" &&
      res::deleted pkg "$1" ||
      err::trace "Unable to destroy package: $1"
  else
    return 1
  fi
}

# private pkg::_create::archlinux <package>
pkg::_create::archlinux () {
  tmp::exists pkg_update_archlinux || pkg::_update::archlinux
  mutex::run pkg_archlinux std::run std::mute pacman -S --noconfirm "$1"
}

# private pkg::_destroy::archlinux <package>
pkg::_destroy::archlinux () {
  mutex::run pkg_archlinux std::run std::mute pacman -R --noconfirm "$1"
}
#! /bin/bash
# mod: format
# api: potion
# txt: The `format` module provides a way to format and mount specified
#      block devices.
# use: format::present /dev/sda1 fstype=xfs

# private format::_exists::format <device>
format::_exists::format () {
  std::mute blkid "$1"
}

# fun: format::exists [name=]<device> [options]
# api: potion
# txt: return true if device exists and it's mounted on mountpoint
# opt: name: the device name
format::exists () {
  eval $(std::parse "$@")
  format::_exists::format "$name"
}

# private format::_create::format <device> [fstype]
format::_create::format () {
  std::run mkfs.${2:-ext4} "$1" ||
    err::trace "Unable to format format: $1"

}

# private format::_create::mount <device> <mountpoint> <fstype> <opts>
format::_create::mount () {
  std::run mount ${3:+-t ${3}} ${4:+-o ${4}} "$1" "$2" ||
    err::trace "Unable to mount format: $1"
}

# fun: format::present [name=]<device> [options]
# api: potion
# txt: ensure that specified device has format
# opt: name: the device to be initialized
# opt: fstype: the filesystem type to format the device
format::present () {
  eval $(std::parse "$@")

  if ! format::_exists::format "$name"; then
    format::_create::format "$name" ${fstype} &&
      res::created format "name=$name fstype=$fstype" ||
      err::trace "Unable to format format: $name"
  else
    return 1
  fi
}

# fun: format::absent [name=]<device>
# api: potion
# txt: ensure that specific device is not formatted.
format::absent () {
  out::warn "To avoid data loss format::absent do nothing for device $@"
}

#! /bin/bash
# mod: pkg
# api: potion
# txt: The `pkg` module provides functions to ensure package installation
#      on the system.
# use: pkg::present vim

# fun: pkg::exists [name=]<package>
# api: potion
# txt: return true if the specific package is present in the system.
pkg::exists () {
  eval $(std::parse "$@")
  local os="$(os::provider)"

  if std::func pkg::_exists::${os}; then
    pkg::_exists::${os} "$name"
    return $?
  else
    err::trace "Potion does not support '$os' operating system... yet"
  fi
}

# fun: pkg::present [name=]<package>
# api: potion
# txt: ensure that specified package is installed on the system.
pkg::present () {
  eval $(std::parse "$@")
  local os="$(os::provider)"

  if std::func pkg::_present::${os}; then
    pkg::_present::${os} "$name"
    return $?
  else
    err::trace "Potion does not support '$os' operating system... yet"
  fi
}

# fun: pkg::absent [name=]<package>
# api: potion
# txt: ensure that specified package is not present on the system.
pkg::absent () {
  eval $(std::parse "$@")
  local os="$(os::provider)"

  if std::func pkg::_absent::${os}; then
    pkg::_absent::${os} "$name"
    return $?
  else
    err::trace "Potion does not support '$os' operating system... yet"
  fi
}
#! /bin/bash
# mod: link
# api: potion
# txt: The `link` module provides functions to ensure that specified
#      symlink exists in the system and points to specified file.
# use: link::present /mylink target=/etc/motd

# fun: link::exists [name=]<link> target=<source>
# api: potion
# txt: returnt true if the specified link exists and point to source.
# opt: target: the target where link points to
link::exists () {
  eval $(std::parse "$@")
  [ "$target" ] || err::trace "Link::exists require parameter target"
  [ -L "$name" ] && [ "$(readlink "$name")" == "$target" ]
}

# private link::_create <link> <source>
link::_create () {
  std::run ln -sf "$2" "$1"
}

# private link::_destroy <link> [source]
link::_destroy () {
  std::run rm -f "$1"
}

# fun: link::present [name=]<link> target=<source>
# api: potion
# txt: ensure that the link exists and point to source.
# opt: target: the target where link points to
link::present () {
  if ! link::exists "$@"; then
    eval $(std::parse "$@")
    link::_create "$name" "$target" &&
      res::created link "$name" "target=$target" ||
      err::trace "Unable to create link: $name ($target)"
  else
    return 1
  fi
}

# fun: link::absent [name=]<link> target=<source>
# api: potion
# txt: ensure that the specified link does not exists or not point to
#      specified source.
# opt: target: the target where link points to
link::absent () {
  eval $(std::parse "$@")
  if link::exists "$@"; then
    link::_destroy "$name" "$target" &&
      res::deleted link "$name" "target=$target" ||
      err::trace "Unable to destroy link: $name ($target)"
  else
    return 1
  fi
}

#! /bin/bash
# mod: file
# api: potion
# txt: The `file` module provides functions to ensure that specified file
#      exists or not in the system and also has specified content.
#      To creat content, use the ``data`` parameter, usually this parameter
#      accepts a URL in the form:
#      
#
#        * `file://x`: where x is a file in the host where potion is executed.
#        * `artifact://x`: an artifact provided in the potion file.
#        * `artifact+eval://x`: an evaluate artifact.
#        * `http://x` or `https://x`: a remote web site.
#        * `ftp://x`: a FTP remote site.
#        
# use: file::present /etc/somefile \\
#        data="artifact://someartifact"
# use: file::present /etc/otherfile \\
#        data="some string content"

# private file::hmac <url>
file::_hmac () {
  ALGO="${ALGO:=sha1}"
  local hmac=
  local path="$(os::path ${ALGO}sum)"

  if [ "$path" ]; then
    hmac="$(file::_data "$1" | ${ALGO}sum)"
    read hmac _ <<<"${hmac}"
    echo "$hmac"
  else
    err::trace "Required binary '${ALGO}sum' is not installed"
  fi
}

# private file::_data <url>
file::_data () {
  case "$1" in
    artifact://*) 
      local name="${1##artifact://}"
      artifact::exists "${name}" ||
        err::trace "Missing artifact: $1"
      artifact::read "$name"
      ;;
    artifact+eval://*)
      local name="${1##artifact+eval://}"
      artifact::exists "${name}" ||
        err::trace "Missing artifact: $1"
      artifact::eval "$name"
      ;;
    http://*|https://*|ftp://*)
      curl::get "$1"
      ;;
    file://*)
      cat "${1#file://}"
      ;;
    *)
      echo "$1"
      ;;
  esac
}

# fun: file::exists [name=]<fname> [options]
# api: potion
# txt: return true if file exists, or none otherwise
# opt: name: the filename to check for.
# opt: data: the content URL
file::exists () {
  eval $(std::parse "$@")

  [ -r "$name" ] || return 1

  local old_hmac="$(file::_hmac "file://$name")"
  local new_hmac="$(file::_hmac "$data")"
  [ "$new_hmac" == "$old_hmac" ]
}

# private file::create <fname> <owner:group> <mode> <data>
file::_create () {
  # we required an explitic if here because of the redirection.
  if ! ${PRETEND:-false}; then
    file::_data "$4" > "$1" ||
      err::trace "Unable to dump content to file: $1"
  fi

  std::run chown "${2:-0:0}" "$1" &&
    std::run chmod "${3:-644}" "$1" ||
    err::trace "Unable to set permissions to file: $1"
}

# private file::destroy <fname>
file::_destroy () {
  std::run rm -f "$1"
}

# fun: file::present [name=]<name> [options]
# api: potion
# txt: ensure that file passed as argument exists.
# opt: name: then file name to ensure
# opt: user: the user owner the file
# opt: group: the group owner the file
# opt: mode: the octal mode of the file
# opt: data: the content url
file::present () {
  eval $(std::parse "$@")
  local group="${group:-$LOGNAME}"
  local user="${user:-$LOGNAME}"

  if ! file::exists "$name" "data=$data"; then
    file::_create "$name" "${user}:${group}" "${mode:-644}" "$data" &&
      res::created file \
        "name=$name user=${user} group=${group} mode=${mode:-0644}" ||
      err::trace "Unable to create file: $name"
  else
    return 1
  fi
}

# fun: file::absent [name=]<name> [options]
# api: potion
# txt: ensure that file passed as argument does not exist.
# opt: data: the content url (only removes the file if data is the same).
file::absent () {
  eval $(std::parse "$@")
  if file::exists "$name" "data=$data"; then
    file::_destroy "$name" &&
      res::deleted file "name=$name" ||
      err::trace "Unable to destroy file: $name"
  else
    return 1
  fi
}
#! /bin/bash
# mod: sudo
# txt: The `sudo` module provides functions to grant or deny permissions
#      to specific users.
# env: SUDOERS_DIR: the path where sudoers file exists, usually
#      `/etc/sudoers.d`.
# use: # ensure taht user someuser has ALL permissions
#      sudo::user::present someuser grant=ALL
# use: # ensure that group somegroup does not have ALL permissiones
#      sudo::group::absent somegroup grant=ALL

SUDOERS_DIR=/etc/sudoers.d

# private sudo::sytax <file>
sudo::_syntax () {
  std::mute visudo -cf "$1"
}

# fun: sudo::user::exists [name=]<username> grant=<permissions>
# api: potion
# txt: return true if user has specific permissions
# opt: name: the username to check permissions
# opt: grant: the permissions to granted to the user.
sudo::user::exists () {
  eval $(std::parse "$@")
  std::mute grep "^$name $grant$" "${SUDOERS_DIR}/20_user_$name"
}

# private sudo::user::_create <username> <sudoline>
sudo::user::_create () {
  if ! ${PRETEND:-false}; then
    echo "$1 $2" >> "${SUDOERS_DIR}/20_user_$1"
    if ! sudo::_syntax "${SUDOERS_DIR}/20_user_$1"; then
      rm -f "${SUDOERS_DIR}/20_user_$1"
      err::trace "Invalid syntax in sudoers file: '$2'"
    fi
  fi
}

# private sudo::user::_destroy <username> <sudoline>
sudo::user::_destroy () {
  if ! ${PRETEND:-false}; then
    local data="$(grep -v "^$1 $2$" "${SUDOERS_DIR}/20_user_$1")"
    echo "$data" > "${SUDOERS_DIR}/20_user_$1"
    if ! sudo::_syntax "${SUDOERS_DIR}/20_user_$1"; then
      rm -f "${SUDOERS_DIR}/20_user_$1"
      err::trace "Invalid syntax in sudoers file: '$2'"
    fi
  fi
}

# fun: sudo::user::present [name=]<username> grant=[permissions]
# api: potion
# txt: ensure that specific user has permissions passed as argument, or if
#      not permissions defined grant root permissions.
# opt: name: the username to give permissions
# opt: grant: the permissions to granted to the user (by default ALL
#      NOPASSWD)
sudo::user::present () {
  eval $(std::parse "$@")
  local grant="${grant:-ALL=(ALL) NOPASSWD: ALL}"

  if ! sudo::user::exists "$name" "grant=$grant"; then
    sudo::user::_create "$name" "${grant}" &&
      res::created sudo "user=$name" "grant=${grant}" ||
      err::trace "Unable to create sudo permissions for user $1 ('$grant')"
  else
    return 1
  fi
}

# fun: sudo::user::absent [name=]<username> grant=[permissions]
# api: potion
# txt: ensure that the specific permission for the specific username is not
#      granted.
# opt: name: the username to give permissions
# opt: grant: the permissions to granted to the user
sudo::user::absent () {
  eval $(std::parse "$@")
  local grant="${grant:-ALL=(ALL) NOPASSWD: ALL}"

  if sudo::user::exists "$1" "grant=$grant"; then
    sudo::user::_destroy "$1" "${grant}" &&
      res::deleted sudo "user=$user" "grant=$grant" ||
      err::trace "Unable to destroy sudo permissions for user $name ('$grant')"
  else
    return 1
  fi
}

# fun: sudo::group::exists [name=]<username> grant=<sudoline>
# api: potion
# txt: return true if group has configured the specific sudoline.
# opt: name: the username to give permissions
# opt: grant: the permissions to granted to the user
sudo::group::exists () {
  eval $(std::parse "$@")
  std::mute grep "^%$name $grant$" "${SUDOERS_DIR}/20_group_$name"
}

# private sudo::group::_create <groupname> <sudoline>
sudo::group::_create () {
  if ! ${PRETEND:-false}; then
    echo "%$1 $2" >> "${SUDOERS_DIR}/20_group_$1"
    if ! sudo::_syntax "${SUDOERS_DIR}/20_group_$1"; then
      rm -f "${SUDOERS_DIR}/20_group_$1"
      err::trace "Invalid syntax in sudoers file: '$2'"
    fi
  fi
}

# private sudo::group::_destroy <groupname> <sudoline>
sudo::group::_destroy () {
  if ! ${PRETEND:-false}; then
    local data="$(grep -v "^%$1 $2$" "${SUDOERS_DIR}/20_group_$1")"
    echo "$data" > "${SUDOERS_DIR}/20_group_$1"
    if ! sudo::_syntax "${SUDOERS_DIR}/20_group_$1"; then
      rm -f "${SUDOERS_DIR}/20_group_$1"
      err::trace "Invalid syntax in sudoers file: '$2'"
    fi
  fi
}

# fun: sudo::group::present [name=]<groupname> [grant=permissions]
# api: potion
# txt: ensure that specific group has permissions passed as argument, or if
#      not permissions defined grant root permissions.
# opt: name: the username to give permissions
# opt: grant: the permissions to granted to the user (by default ALL
#      NOPASSWD)
sudo::group::present () {
  eval $(std::parse "$@")
  local grant="${grant:-ALL=(ALL) NOPASSWD: ALL}"

  if ! sudo::group::exists "$name" "$grant"; then
    sudo::group::_create "$name" "${grant}" &&
      res::created sudo "group=$name" "grant=${grant}" ||
      err::trace "Unable to create sudo permissions for group $name ('$grant')"
  else
    return 1
  fi
}

# fun: sudo::group::absent [name=]<groupname> [grant=permissions]
# api: potion
# txt: ensure that the specific permission for the specific groupname is not
#      granted.
# opt: name: the username to give permissions
# opt: grant: the permissions to granted to the user (by default ALL
#      NOPASSWD)
sudo::group::absent () {
  eval $(std::parse "$@")
  local grant="${grant:-ALL=(ALL) NOPASSWD: ALL}"

  if sudo::group::exists "$name" "$grant"; then
    sudo::group::destroy "$name" "${grant}" &&
      res::deleted sudo "group=$name" "grant=${grant}" ||
      err::trace "Unable to destroy sudo permissions for group $name ('$grant')"
  else
    return 1
  fi
}
#! /bin/bash
# mod: user
# api: potion
# txt: The `user` module provides functions to manage users in the system.
# use: group::present mygroup
#      user::present someuser \\
#        groups=adm,mygroup \\
#        nohome=true \\
#        system=true \\
#        shel=/bin/false

# fun: user::exists [name=]<username>
# txt: return true or false if the specific username exists or not,
#      respectively.
user::exists () {
  eval "$(std::parse "$@")"
  # shellcheck disable=SC2154
  std::mute id "$name"
}

# private user::_home <username>
user::_home () {
  eval echo "~$1"
}

# private user::_create <username> [password]
# create specific username passed as argument.
# USER_BASE_DIR: set the base director to create home directories.
# USER_COMMENT: set the GECOS field in user record.
# USER_GROUPS: a comma separated list of groups for the user.
# USER_NOHOME: if true do not create home directory (false by default).
# USER_SYSTEM: if true create system user (false by default).
# USER_UID: if set, try to force that UID as user id for the new user.
# USER_SHELL: set the shell of the username.
user::_create () {
  local ua_opts=""
  local ua_opts+="${USER_BASE_DIR:+-b ${USER_BASE_DIR} }"
  local ua_opts+="${USER_COMMENT:+-c ${USER_COMMENT} }"
  local ua_opts+="${USER_GROUPS:+-G ${USER_GROUPS} }"
  if ${USER_NOHOME:-false}; then
    local ua_opts+="-M "
  else
    local ua_opts+="-m "
  fi
  local ua_opts+="${USER_SYSTEM:+-r }"
  local ua_opts+="${USER_UID:+-u ${USER_UID} }"
  local ua_opts+="${USER_SHELL:+-s ${USER_SHELL} }"

  [ "$2" ] && local ua_opts+="-U"

  std::run useradd $ua_opts "$1"

  if [ "$2" ]; then 
    std::run passwd "$1" <<< "$2"
  fi
}

# private user::_destroy <username>
# destroy the username passed as argument.
# USER_KEEPDATA: if set do not remove home directory and other user files.
user::_destroy () {
  std::run userdel -f "${USER_KEEPDATA:--r}" "$1"
}


# fun: user::present [name=<username>] [options]
# api: potion
# txt: create user if not exists
# opt: basedir: set the base director to create home directories.
# opt: gecos: set the GECOS field in user record.
# opt: groups: a comma separated list of groups for the user.
# opt: nohome: if true do not create home directory (false by default).
# opt: system: if true create system user (false by default).
# opt: uid: if set, try to force that UID as user id for the new user.
# opt: shell: set the shell of the username.
# opt: password: the password for the user
user::present () {
  eval "$(std::parse "$@")"
  # shellcheck disable=SC2154
  if ! user::exists "$name"; then
    USER_BASE_DIR="${basedir}" \
    USER_COMMENT="${gecos}" \
    USER_GROUPS="${groups}" \
    USER_NOHOME="${nohome}" \
    USER_SYSTEM="${system}" \
    USER_UID="${uid}" \
    USER_SHELL="${shell}" \
    user::_create "$name" "$password" &&
      res::created user "$name" basedir="$basedir" gecos="$gecos" \
        groups="$groups" nohome="$nohome" system="$system" uid="$uid" \
        shell="$shell" ||
      err::trace "unable to create user: $name"
  else
    return 1
  fi
}

# fun: user::absent [name=]<username> [keepdata=true]
# api: potion
# txt: destroy username if exists
# opt: keepdata: if true do not remove user data.
user::absent () {
  eval $(std::parse "$@")
  if user::exists "$name"; then
    USER_KEEPDATA="${data}" \
    user::_destroy "$name" &&
      res::deleted user "$name" ||
      err::trace "unable to destroy user $name"
  else
    return 1
  fi
}
#! /bin/bash
# mod: mount
# api: potion
# txt: The `mount` module provides functions to ensure that specific
#      mountpoint is mounted.
# use: mount::present /mnt device=/dev/sda1 fstype=xfs

# fun: mount::exists [name=]<name> [opts]
# api: potion
# txt: return true if specific device is mounted with passed options
# opt: device: the device to mount
# opt: fstype: the fstype of the device filesystem (default: auto)
mount::exists () {
  eval $(std::parse "$@")
  while read _dev _ _mnt _ _fstype _; do
    [ "$_mnt" == "${name}" ] && return 0
  done < <(mount)
  return 1
}

mount::_create () {
  eval $(std::parse "$@")
  mount_opt="${fstype:+-t $fstype}"
  std::run mount ${mount_opt} ${device} "${name}"
}

mount::_destroy () {
  eval $(std::parse "$@")
  std::run umount "$name"
}

# fun: mount::present [name=]<name> [opts]
# api: potion
# txt: ensure that specific device is mounted according with passed options.
# opt: device: the device to mount
# opt: fstype: the fstype of the device filesystem (default: auto)
mount::present () {
  if ! mount::exists "$@"; then
    mount::_create "$@" &&
      res::created mount "$@" ||
      err::trace "Unable to mount $@"
  else
    return 1
  fi
}

# fun: mount::absent [name=]<name>
# api: potion
# txt: ensure that specific mount point is not mounted.
mount::absent () {
  if mount::exists "$@"; then
    mount::_destroy "$@" &&
      res::deleted mount "$@" ||
      err::trace "Unable to umont $@"
  else
    return 1
  fi
}
#!/bin/bash
# mod: artifact
# txt: The `artifact` module contains function to access to artifacts. An
#      artifact is a file embedded in potion compiled object, usually you
#      want to set some configuration files as artifacts.

# fun: artifact::hmac <artifact_name>
# txt: print to stdout the HMAC of the artifact passed as argument.
# env: ALGO: set the algorithm to use for calculate HMAC. Valid values are:
#      sha1, md5, sha256, sha512. The proper helper tool must be installed
#      on the system.
artifact::hmac () {
  if artifact::exists "$1"; then
    file::hmac "${BLIB_TMPDIR}/_artifacts/$1"
  else
    err::trace "Missing artifact while calculating HMAC: $1"
  fi
}

# fun: artifact::extract
# txt: extract artifacts if artifact support is enabled.
artifact::extract () {
  [ "$POTION_ARTIFACTS" ] || return 0
  [ -e "${BLIB_TMPDIR}/.artifacts" ] && return 0

  mutex::adquire _artifacts
  tmp::create _artifacts
  echo "${POTION_ARTIFACTS}" | base64 -d | tar x -C . ||
    err::trace "Unable to extract artifacts"
  touch "${BLIB_TMPDIR}/.artifacts"
  tmp::exit
  mutex::release _artifacts
}

# fun: artifact::exists <artifact_name>
# txt: return true if the artifact exists, false otherwise.
artifact::exists () {
  artifact::extract
  [ -r "${BLIB_TMPDIR}/_artifacts/$1" ]
}

# fun: artifact::read <artifact_name>
# txt: read a specific artifact from potion.
artifact::read () {
  artifact::exists "$1" ||
    err::trace "Missing artifact: '$1'"

  cat "${BLIB_TMPDIR}/_artifacts/$1"
}


# fun: artifact::eval <artifact_name>
# txt: read and eval specific artifact from potion.
artifact::eval () {
  artifact::exists "$1" ||
    err::trace "Missing artifact: '$1'"

  local content

  content="$(< "${BLIB_TMPDIR}/_artifacts/$1")"
  eval echo -n \""${content//\"/\\\"}"\"
}

# fun: artifact::build <directory>
# txt: scan the directory passed as argument and return a POTION_ARTIFACTS
#      variable to stdout with the encoded version of the artifacts.
artifact::build () {
  local artifacts
  artifacts="$(cd "$1" && tar -c . | base64 -w0)"
  echo "POTION_ARTIFACTS='${artifacts}'"
  echo
}

# fun: artifact::load <directory>
# txt: load in environment potion artifacts
artifact::load ()
{
  eval "$(artifact::build "${1}")"
  out::user "dumped artifacts from: ${1}"
}
#! /bin/bash
# mod: debug
# api: blib
# txt: The debug module enable or disable debug featuring.
# env: DEBUG: if true enable debug mode

${DEBUG:+set -x}
#! /bin/bash
# mod: config
# api: blib
# txt: The `config` module allows you to read configuration file in
#      properties format
# use: config::load configname ./config.properties
#      echo $(config::get configname key)

declare -A __config

# fun: config::load <table> <file>
# api: blib
# txt: read a configuration file passed as argument and save in the memory
#      with specific table name.
# opt: table: a name to identify the config table where file will be load.
# opt: file: path to a properties file to load.
config::load ()
{
  local line= key= val=
  while read line; do
    case "$line" in
      \#*|'') continue;;
    esac
    IFS=':' read key val <<< "$line"
    __config["$1.$key"]="$val"
  done < "$2"
}

# fun: config::get <table> <key> [default]
# api: blib
# txt: outputs the specified configuration key in the table passed as
#      argument. If key does not exists raise an error, unless default
#      is passed as argument, in that case return default values.
# opt: table: the table name where to search key.
# opt: key: the key to search in config table
# opt: default: default value to output if value is not found. By default
#      an error is raised.
config::get ()
{
  local val="${__config["$1.$2"]}"

  if [ "$3" ]; then
    [ "$val" ] && echo "$val" || echo "$3"
  else
    [ "$val" ] && echo "$val" || err::trace "Configuration key " \
                                            "$2 in table $1 not found"
  fi
}

# fun: config::iter <table> <pattern>
# api: blib
# txt: iterate over a specific configuration using pattern passed as
#      argument and outputs keys with match.
# opt: table: the table name to iterate
# opt: pattern: a glob pattern to match in config keys.
config::iter ()
{
  for key in "${!__config[@]}"; do
    case "$key" in
      ${1}.${2})

        echo "${key#${1}.}";;
    esac
  done
}
#! /bin/bash
# mod: cache
# api: blib
# txt: The `cache` module provides a simple in-memory cache.
# use: cache::put "key" "val"
#      cache::get "key"

# fun: cache::get <key>
# api: blib
# txt: get the value of the key from the potion in-memory cache.
cache::get () {
  echo "${cache__contents["$1"]}"
}

# fun: cache::put <key> <value>
# api: blib
# txt: save the content of the specified key to the in-memory cache.
cache::put () {
  cache__contents["$1"]="$2"
}

declare -A cache__contents
#! /bin/bash
# mod: term
# api: blib
# txt: The `term` module provides functions related with terminal
#      configuration. This module also define some useful color variables to
#      be used in `out` module.

# fun: term::attached
# api: blib
# txt: return true if output is a terminal, false otherwise
term::attached () { [ -t 1 ]; }

# fun: term::tcap <capability>
# api: blib
# txt: check if some capabilty is enabled in terminal
term::tcap () { tput "$1" 2>/dev/null; }

if term::attached; then
  case "$(term::tcap colors)" in
    256)
      COLOR_NONE=$'\033[0;0;0m'
      COLOR_INFO=$'\033[38;5;79m'
      COLOR_WARN=$'\033[38;5;190m'
      COLOR_FAIL=$'\033[38;5;160m'
      COLOR_DATE=$'\033[38;5;242m'
      COLOR_USER=$'\033[38;5;201m'
      COLOR_BOLD=$'\033[1;15m'
      ;;
  esac
fi
#! /bin/bash
# mod: mutex
# api: blib
# txt: The `mutex` module provides a way to ensure critical region access
#      across different processes. NOTE this module does not work fine on some
#      filesystems, like NFS, AFS and others.
# use: mutex::run mymutex sleep 10 # run a sleep in a critical region
#      mutex::adquire mymutex
#      # do some critical changes
#      mutex::release mymutex

# fun: mutex::adquire <name>
# api: blib
# txt: create a mutex or wait until mutex removed
# opt: name: the name to identify this mutex
mutex::adquire () {
  local i=0
  tmp::create _mutex
  while ! std::mute mkdir "_mutex_$1"; do
    [ $i -eq ${MUTEX_TIMEOUT:-3600} ] && err::trace "Mutex timeout: $1"
    ${VERBOSE:-false} && out::user "waiting for mutex: $1 ($_run)"
    std::sleep 1
    ((i++))
  done
  tmp::exit
  ${VERBOSE:-false} && out::user "adquired mutex: $1 ($_run)"
}

# fun: mutex::release <name>
# api: blib
# txt: release mutex by name
# opt: name: the name to identify this mutex
mutex::release () {
  tmp::create _mutex
  ${VERBOSE:-false} && out::user "releasing mutex: $1 ($_run)"
  rmdir "_mutex_${1}"
  tmp::exit
}

# fun: mutex::run <name> <command> [args]
# api: blib
# txt: run a command protected by mutex named as argument name.
# opt: name: the name to identify this mutex
# opt: command: the command to run
# opt: args: optional arguments to the command.
mutex::run () {
  local name="$1"; shift
  _run="$@"
  mutex::adquire "$name"
  "$@"
  local ret=$?
  mutex::release "$name"
  return $ret
}
#! /bin/bash
# mod: out
# api: blib
# txt: The `out` module provides functions to output messages in stderr or
#      stdout.

# fun: out::log <message> [message_type]
# api: blib
# txt: print to stdout a log line with specified message and prefixed by
#      date and message_type.
# env: DATE_FORMAT: defines the format for the datetime, in regular date(1)
#      format.
# env: COLOR_DATE: defines the color to use (if available) to print the date.
# env: COLOR_MESSAGE: defines the color to use to print the message.
# env: COLOR_NONE: defines the sequence to reset defined color.
# env: QUIET: if true do not show any messages
DATE_FORMAT="%Y-%m-%d %H:%M:%S"
out::log () {
  ${QUIET:-false} ||
  printf "${COLOR_DATE}%s${COLOR_NONE} %s: ${COLOR_MESSAGE}%s${COLOR_NONE}\n" \
    "$(date +"$DATE_FORMAT")" \
    "${2:-${COLOR_USER}user${COLOR_NONE}}" \
    "$1"
}

# fun: out::info <message>
# api: blib
# txt: print an informational message in stdout.
# env: COLOR_INFO: defines the color to be used in informational messages.
out::info () { out::log "$1" "${COLOR_INFO}info${COLOR_NONE}"; }

# fun: out::fail <message>
# txt: print an informational message in stdout.
# txt: print an error message in stderr.
# env: COLOR_FAIL: defines the color to be used in this kind of messages.
#      E: if set exit program with error code defined in the variable
out::fail () {
  out::log "$1" "${COLOR_FAIL}fail${COLOR_NONE}" >&2;
  ${E:+exit $E}
}

# fun: out::warn <message>
# txt: print an informational message in stdout.
# txt: print a warning message in stderr.
# env: COLOR_WARN: defines the color to be used in this kind of messages.
out::warn () { out::log "$1" "${COLOR_WARN}warn${COLOR_NONE}" >&2; }

# fun: out::user <message>
# txt: print an informational message in stdout.
# txt: print a user defined message in stdout
# env: COLOR_USER: defines the color to be used in this kind of messages.
out::user () { out::log "$1" "${COLOR_USER}user${COLOR_NONE}"; }
#! /bin/bash
# mod: std
# api: blib
# txt: The `std` module contains a numer of standard functions usefull to
#      progamming in bash.

# fun: std::quit
# api: blib
# txt: perform an exit clean of the running program.
std::quit () {
  for handler in ${std__quit_handler[@]}; do
    $handler
  done
}

# fun: std::add_quit_handler <func_name>
# api: blib
# txt: Add func_name as handler to execute before quit the application.
#      When the application finished, then the functions registered as quit
#      handlers will be executed in the same order than they were
#      registered.
# opt: func_name: the name of the function to be registered.
# use: somefunc () { echo "exiting"; }
#      std::add_quit_handler somefunc
declare -A std__quit_handler
std__quit_handler["tmp"]="tmp::destroy"
std::add_quit_handler () {
  std__quit_handler["$1"]="$2"
}
trap std::quit EXIT
trap std::quit CHLD

# fun: std::hmac <text>
# api: blib
# txt: outputs the calculated HMAC using SHA1 for the text passed as
#      argument.
# opt: text: a plain text to be hashed.
# env: ALGO: set the algorithm to use for calculate HMAC. Valid values are:
#      sha1, md5, sha256, sha512. The proper helper tool must be installed
#      on the system.
# use: std::hmac "hello world"
#      ALGO=md5 std::hmac "hello world"
std::hmac () {
  ALGO="${ALGO:=sha1}"
  local sum=
  local path="$(os::path ${ALGO}sum)"
  if [ "$path" ]; then
    sum="$(echo -n "$1" | ${ALGO}sum)"
    read sum _ <<<"$sum"
    echo "$sum"
  else
    err::trace "Required binary '${ALGO}sum' not found"
  fi
}

# fun: std::mute <command>
# api: blib
# txt: mute outputs, including `stderr` when running a command, alias or
#      function
# opt: command: the command to run muted.
std::mute () {
  "$@" >/dev/null 2>/dev/null
}

# fun: std::strin <str1> <str2>
# api: blib
# txt: return true if `str1` is into `str2`, or false otherwise.
# opt: str1: the string which could be contain `str2` and wants to evaluate
# opt: str2: the string to find into `str1`
# use: std::strin "somelargestring" "some"
std::strin () {
  [ "${1//$2/}" != "${1}" ]
}

# fun: std::sleep <seconds>
# api: blib
# txt: sleep for specified number of seconds. This function is pure-bash, so
#      not need sleep(1) command.
std::sleep () {
  read -N 0 -t "$1" -s -r </dev/tty 3<&- 3<&0 <&3
}

# fun: std::func <func_name>
# api: blib
# txt: return true if function name passed as argument is defined, or false
#      otherwise.
std::func () {
  std::mute declare -f "$1"
}

# fun: std::arch
# api: blib
# txt: outputs the hardware architecture of the current host.
std::arch () {
  uname -m
}

# fun: std::timestamp
# api: blib
# txt: outputs the UNIX timestamp
# env: TZ: the timezone to use to print the timestamp, by default get the
#      timezone from the system.
std::timestamp () {
  printf "%(%s)T\n"
}

# fun: std::parse <arg_string>
# api: blib
# txt: parse an argument string in the form key=value and promote this
#      variables to environment. The key `name` is mandatory. If the
#      first parameter has no key, key `name` is using by default.
# use: std::parse "name=Jhon age=90"
#      echo "$name has $age years old"
std::parse () {
  local hasname=false
  local fst="$1"; shift

  [ "${fst#name=}" != "${fst}" ] || fst="name=$fst"

  for arg in "$fst" "$@"; do
    std::strin "$arg" "=" || err::trace "Invalid argument: $arg"
    [ "${arg#name=}" != "${arg}" ] && hasname=true
    echo -n "local ${arg/=/=\'}';"
  done
  ${hasname} || err::trace "The parameter 'name' is mandatory"
  shift
  echo
}

# fun: std::run <command>
# api: blib
# txt: Run command passed as argument if $PRETEND is not set to true
# env: PRETEND: if true do nothing.
std::run () {
  ${PRETEND:-false} || "$@"
}

# fun: std::installed <command>
# api: blib
# txt: return true if command is installed in path
std::installed () {
  std::mute type -p "$1"
}

# fun: std::is_dir_empty <dir>
# api: blib
# txt: return true if dir is empty
std::is_dir_empty () {
  for f in $1/*; do
    [ "$f" == "$1/*" ] && return 0
    return 1
  done
}

# fun: std::sort <array>
# api: blib
# txt: sort an array using qsort in pure bash (not very efficient) and
#      return the output to an special variable called `sort_ret`.
# env: sort_ret: will contain the sorted array
std::sort () {
   local pivot i smaller=() larger=()
   sort_ret=()
   (($#==0)) && return 0
   local pivot="$1"
   shift
   for i; do
      if [[ "$i" < "$pivot" ]]; then
         smaller+=( "$i" )
      else
         larger+=( "$i" )
      fi
   done
   std::sort "${smaller[@]}"
   smaller=( "${sort_ret[@]}" )
   std::sort "${larger[@]}"
   larger=( "${sort_ret[@]}" )
   sort_ret=( "${smaller[@]}" "$pivot" "${larger[@]}" )
}

# fun: str2array <string> [separator]
# api: blib
# txt: create a new array with the contents of the string, using separator
#      passed as argument.
# opt: string: the string to covert to array
# opt: separator: the character to use as separator, by default use comma.
# use: str2array "one,two,three"
#      echo "${str2array_ret[@]}"
std::str2array () {
  local str="$1"
  local sep="${2:-,}"
  # remove [] if present
  str="${str#[}"
  str="${str%]}"

  eval set -- "${str//,/ }"
  str2array_ret=( "$@" )
}
declare -a str2array_ret
#! /bin/bash
# mod: curl
# api: blib
# txt: The curl module offers a way to access to HTTP resources easily.

# fun: curl::get <url>
# api: blib
# txt: get an object from url and output it to stdout
# opt: url: any URL valid for curl.
# use: curl::get http://example.com
curl::get () {
  command curl -qsSL "$1"
}

# fun: curl::source <url>
# api: blib
# txt: sources a file from url
# use: curl::source http://mydomain.com/file.bash
curl::source () {
  case "$1" in
    *://*) source <(curl::get "$1");;
    *) source "$1" ;;
  esac
}
#! /bin/bash
# mod: arg
# api: blib
# txt: The `arg` module provides a number of functions to parse arguments
#      from command line.
#
#      To use `arg` module you need to create handler functions which will
#      be call during the parser process. The handler functions sould return
#      the number of parameters comsumed from the parameter list. See
#      example below for more information.
# use: opt_quiet () {
#          QUIET=true; return 1; # we consum only the -q param
#      }
#      create () { echo "$arguments" }
#
#      arg::opt MAIN -q --quiet   opt_quiet   'do not output messages'
#
#      arg::action create create 'create new things'
#      arg::param create "arguments+"  'argument to create subcommand'
#
#      arg::parse "$@"


declare -A arg__opt_arg
declare -A arg__opt_long
declare -A arg__opt_short
declare -A arg__opt_help
declare -A arg__actions
declare -A arg__actions_help
declare -A arg__param

# fun: arg::opt <action> <short> <long> <handler> [help]
# api: blib
# txt: set an option for a specific action argument.
# opt: action: the action for which the option will be added
# opt: short: the short form of the option (usually prefixed by ``-``)
# opt: long: the long form of the option (usually prefixed by ``--``)
# opt: handler: function to handler when option is present.
arg::opt () {
  arg__opt_short["$1,${2#-}"]="$4"
  arg__opt_long["$1,${3#--}"]="$4"
  arg__opt_help["$1,${2#-},${3#--}"]="$5"
}

# fun: arg::parse::opt::fail <cmdline>
# txt: exit program with error 2 (cmdline error) interpreting cmdline passed
#      as argument.
# opt: cmdline: the cmdline which fails.
arg::parse::opt::fail () {
  echo "unrecognized command line option '${1}'" >&2
  E=2 arg::usage >&2
}

# fun: arg::parse::opt::long <action> <option> [option argument]
# txt: set the specific long option for the action passed as argument. The
#      option can be suffixed with a colon (:) to specify a mandatory
#      argument.
arg::parse::opt::long () {
  local opt="${2#--}"
  local fun="${arg__opt_long["$1,$opt"]}"
  [ "$fun" ] || 
    local fun="${arg__opt_long["$1,$opt:"]}"

  if [ "$fun" ]; then
    "$fun" "$3"
  else
    arg::parse::opt::fail "${2%:}"
  fi
}

# fun: arg::parse::opt::short <action> <option> [option argument]
# txt: set the specific short option for the action passed as argument. The
#      option can be suffixed with a colon (:) to specify a mandatory
#      argument.
arg::parse::opt::short () {
  local opt="${2#-}"
  local fun="${arg__opt_short["$1,$opt"]}"
  [ "$fun" ] || 
    local fun="${arg__opt_short["$1,$opt:"]}"
  if [ "$fun" ]; then
    $fun "$3"
  else
    arg::parse::opt::fail "${2%:}"
  fi
}

# fun: arg::action <action> <handler> [help_message]
# api: blib
# txt: set a new action in argument parser.
# opt: action: the action name to add to the parser
# opt: handler: the function name to use as handler for this action.
# opt: help_message: a message to print on usage.
arg::action () {
  arg::opt "$1" -h --help "arg::usage::action::explain $1" \
    "print help message about $1 action"
  arg__actions["${1}"]="$2"
  arg__actions_help["${1}"]="$3"
}

# fun: arg::usage::action <action>
# txt: print usage information for the action passed as argument.
arg::usage::action::explain () {
  local summ="usage: $0 ${1//MAIN/}"
  local text=""
  local param=""

  for key in "${!arg__opt_help[@]}"; do
    IFS=',' read action short long <<<"${key}"
    [ "$action" != "$1" ] && continue
    local help_str="${arg__opt_help["$key"]}"

    if [ "${short: -1}" == ":" ]; then
      local argname="${long%:}"
      local argname="${argname/-/_}"
      local argname=" ${argname^^}"
    else
      local argname=''
    fi
    summ+=" [-${short%:}${argname}]"

    if [ "${argname}" ]; then
      text+="$(printf "  %-20s" "-${short%:}${arg}, --${long%:}${argname}")"
      text+=$'\n'
      text+="$(printf "  %-20s %s" '' "${help_str}")"
    else
      text+="$(printf "  %-20s %s" \
               "-${short%:}${arg}, --${long%:}" \
               "${help_str}")"
    fi
    text+=$'\n'
  done

  local spam=''
  for key in "${!arg__param[@]}"; do
    IFS=',' read action par <<<"${key}"
    [ "$action" != "$1" ] && continue
    local help_str="${arg__param["$key"]}"
    param+="$(printf "  %-20s %s" "${par}" "${help_str}")"
    param+=$'\n'
    spam+="${spam:+ }<${par}>"
  done

  if [ "$1" == "MAIN" ]; then
    local sact=''
    for action in "${!arg__actions[@]}"; do
      [ "$action" == "MAIN" ] && continue
      sact+="${sact:+, }$action"
      actions+="$(printf "  %-20s %s" \
                  "${action}" \
                  "${arg__actions_help["$action"]}")"
      actions+=$'\n'
    done
  fi
  echo "$summ${sact:+" {$sact}"}${spam:+ $spam}"
  echo

  [ "$1" == "MAIN" ] && [ "${arg__actions_help["MAIN"]}" ] &&
    echo "${arg__actions_help["MAIN"]}" && echo

  if [ "$actions" ]; then
    echo "command line actions:"
    echo "$actions"
  fi
  if [ "$param" ]; then
    echo "positional parameters:"
    echo "$param"
  fi
  if [ "$text" ]; then
    echo "optional arguments:"
    echo "$text"
  fi

  exit ${E:-0}
}

# fun: arg:::main::help <text>
# api: blib
# txt: Set the main help for the program
# opt: text: the main help string for the program
arg::main::help () {
  arg__actions_help["MAIN"]="$1"
}

# fun: arg:::main::action <fun>
# api: blib
# txt: Set the function handler for main action, used when no action
#      defined.
# opt: fun: the handler for the MAIN action.
arg::main::action () {
  arg__actions["MAIN"]="$1"
}

# fun: arg::usage
# api: blib
# txt: print main usage information
# env: E: the error code to return to OS on exit.
arg::usage () {
  arg::usage::action::explain MAIN
}

# fun: arg::parse::action <action> [arguments]
# txt: parse arguments starting with action passed as argument.
arg::parse::action () {
  local action="$1"; shift;
  while [ $# -ne 0 ]; do
    case "$1" in
      --*=*)
        arg::parse::opt::long "$action" "${1%=*}" "${1#*=}"; shift;;
      --*) arg::parse::opt::long "$action" "$@"; shift $?;;
      -*) arg::parse::opt::short "$action" "$@"; shift $?;;
      *) break;;
    esac
  done
  if [ "$action" == "MAIN" ]; then
    if [ "${arg__actions["MAIN"]}" ]; then
      arg::parse::arg MAIN "$@"; shift $?
    else
      arg::parse::action "$@";
    fi
    return
  else
    arg::parse::arg "$action" "$@"; shift $?
  fi

}

# fun: arg::parse::arg <action> [arguments]
# txt: parse arguments (not options) for specific action passed as argument.
arg::parse::arg () {
  local action="$1"; shift
  if [ -z "$action" ]; then
    echo "missing action command" >&2
    arg::usage >&2
    exit 2
  fi
  local handler="${arg__actions["$action"]}"
  [ "$handler" ] || arg::parse::opt::fail "$action"

  count=0
  for param in "${!arg__param[@]}"; do
    IFS=, read a name <<< "${param}"
    if [ "$action" == "$a" ]; then
      case "$name" in
        +) ((count++));;
        ?|'*') ;;
        *) ((count++));;
      esac
    fi
  done

  if [ $# -lt $count ]; then
    echo "missing arguments: $# found, $count expected" >&2
    arg::usage::action::explain "$action" >&2
    exit 2
  fi

  $handler "$@"
}

# fun: arg::parse [arguments]
# api: blib
# txt: parse arguments according with previous configured parser.
arg::parse () {
  arg::opt MAIN -h --help 'arg::usage' 'print help message'
  arg::parse::action MAIN "$@"
}

# fun: arg::param <action> <parameter_name> [help_str]
# api: blib
# txt: add position parameter to parser.
# opt: action: action where add the parameter
# opt: parameter_name: the name of the paramenter
# opt: help_str: a help string for the parameter to show in usage
arg::param () {
  arg__param["$1,$2"]="$3"
}
#! /bin/bash
# mod: os
# api: blib
# txt: The `os` module provides specified functions to guess the operating
#      system related variables.

# fun: os::family
# api: blib
# txt: print to stdout the operating system family
os::family () {
  uname -o
}

# fun: os::provider
# api: blib
# txt: print the operating system provider (formerly distribution).
os::provider () {
  for f in ${!os__provider[@]}; do
    if [ -r "$f" ]; then
      echo "${os__provider["$f"]}"
      return 0
    fi
  done

  if [ -r /etc/lsb-release ]; then
    std::mute grep 'DISTRIB_ID=Ubuntu' /etc/lsb-release &&
      echo ubuntu && return 0
  fi
  return 1
}
declare -A os__provider
os__provider["/etc/arch-release"]="archlinux"

# fun: os::release
# api: blib
# txt: print to stdout the properly release of operating system provider.
os::release () {
  local provider="$(os::provider)"
  if std::func os::release::${provider}; then
    std::func::os::release::${provider}
  fi
  true
}

# fun: os::path <file>
# api: blib
# txt: return the path of a file in PATH
# opt: file: the file name to find the full path.
# env: PATH: contains the path to search file
os::path () { type -P "$1" 2>/dev/null; }
#! /bin/bash
# mod: err
# api: blib
# txt: The `err` module offers a way to stop potion execution with
#      a traceback.

# fun: err::trace
# api: blib
# txt: print to stderr a traceback of an error.
# use: false || err::trace "Error because of false"
err::trace () {
  echo "${COLOR_FAIL}Traceback (most recent call last):${COLOR_NONE}" >&2
  for ((i=0;; i++)); do
    read line fun file < <(caller $i)
    if [ "$line" ]; then
      echo "${COLOR_FAIL} File '$file', line $line, in $fun${COLOR_NONE}" >&2
    else
      break
    fi
  done
  out::fail "$1"
  exit 127
}
#! /bin/bash
# mod: os.ubuntu
# txt: The ``os.ubuntu`` module extends ``os`` module adding specific
#      functions for Ubuntu based systems.

# fun: os::relase::ubuntu
# txt: return specific relese for ubuntu operating systems.
os::release::ubuntu () {
  IFS='=' read _ release < <(grep "^DISTRIB_RELEASE=" /etc/lsb-release)
  echo "$release"
}
#! /bin/bash
# mod: tmp
# api: blib
# txt: The `tmp` module provides functions to create and destroy temporary
#      directories. Even if you don't remove the temporary file or directoy
#      explicitely, the directory or file will be deleted when program
#      exits.
# env: TMPDIR: a subdirectory into /tmp to use to create temporary files or
#      directories.
# env: BLIB_TMPDIR: a full path to temporary directory to use to store files
#      or other directories.
# use: tmp::create
#      # do some actions in current directory, which is temporary one
#      tmp::destroy
# use: echo $(tmp::file)

BLIB_TMPDIR="/tmp/${TMPDIR:-blib}"

__current_tmp=
# fun: tmp::create <dirname>
# api: blib
# txt: create temporary directory and move working directory into it
tmp::create () {
  __current_tmp="$PWD"
  mkdir -p "${BLIB_TMPDIR}/$1" && cd "${BLIB_TMPDIR}/$1"
  std::add_quit_handler tmp tmp::destroy
}

# fun: tmp::exit
# api: blib
# txt: exit the temporary directory, but not remove it.
tmp::exit () {
  cd "${__current_tmp:-/}"
}

# fun: tmp::destroy
# api: blib
# txt: move to root directoy and remove temporary directory
tmp::destroy () {
  tmp::exit && rm -rf "${BLIB_TMPDIR}/$1" && unset __current_tmp
}

# fun: tmp::exists <name>
# api: blib
# txt: return true if the specified file name or directory name is
#      a temporary file or directory.
tmp::exists () {
  [ -e "${BLIB_TMPDIR}/$1" ]
}

# fun: tmp::file
# api: blib
# txt: print to stdout the name of unique temporary file.
tmp::file () {
  mkdir -p "${BLIB_TMPDIR}" && echo ${BLIB_TMPDIR}/$$-${RANDOM}
  std::add_quit_handler tmp tmp::destroy
}

# fun: tmp::touch <name>
# api: blib
# txt: create a temporary file with specified name in temporary directory.
tmp::touch () {
  mkdir -p "${BLIB_TMPDIR}" && : > "${BLIB_TMPDIR}/$1"
}
BLIB_VERSION='1.0.1'
#! /bin/bash
# mod: main
# txt: The ``main`` module contain the specified potion body.

VERSION="0.2.7"
export CONTEXT="main"

# fun: main::init
# txt: print nice potion logo and some custom messages at the beginning.
main::init () {
  out::user ""
  out::user "${COLOR_USER}                                   o${COLOR_NONE}"
  out::user "${COLOR_USER}                                     o${COLOR_NONE}"
  out::user "                                   ___"
  out::user "${COLOR_WARN} ____       _   _                  ${COLOR_NONE}| |"
  local m="${COLOR_WARN}|  _ \\ ___ | |_(_) ___  _ __       "
  m+="${COLOR_NONE}|${COLOR_USER}o${COLOR_NONE}|"
  out::user "$m"
  local m="${COLOR_WARN}| |_) / _ \| __| |/ _ \| '_ \\    ${COLOR_NONE}.'   '."
  out::user "$m"
  local m="${COLOR_WARN}|  __/ (_) | |_| | (_) | | | |  ${COLOR_NONE}/   "
  m+="${COLOR_USER}o${COLOR_NONE}   \\"
  out::user "$m"
  local m="${COLOR_WARN}|_|   \\___/ \\__|_|\___/|_| |_|  "
  m+="${COLOR_NONE}:${COLOR_USER}____o__${COLOR_NONE}:"
  out::user "$m"
  local m="                                '.${COLOR_USER}"
  m+="_____${COLOR_NONE}.'"
  out::user "$m"
  out::user "${COLOR_USER}version${COLOR_NONE} ${VERSION}" 
  out::user "detected hardware architecture: $(std::arch)"
  out::user "detected os family: $(os::family)"
  out::user "detected os provider: $(os::provider)"
}

# general options handlers
main::opt_debug () { set -x; return 1;}
main::opt_version () { out::info "Potion $VERSION"; exit 0;}
main::opt_quiet () { QUIET=true; return 1;}
main::opt_pretend () { export PRETEND=true; return 1;}
main::opt_verbose () { export VERBOSE=true; return 1;}

# create action
main::create::opt_artifacts () { main__create__artifacts="$1"; return 2;}
main::create::opt_compress () { main__create__compress=true; return 1;}
main::create::opt_output () { main__create__output="$1"; return 2;}
main::create::opt_secrets () { main__create__secrets="$1"; return 2;}

export artifacts
main::create () {
  local output=$'#! /bin/bash\nPOTION_COMPILED=true\n'
  ${QUIET:-false} || main::init
  out::info "output file: ${main__create__output:=./a.potion}"
  output+="$(<"$0")"$'\n'
  if [ "${main__create__artifacts}" ]; then
    [ -d "${main__create__artifacts}" ] ||
      err::trace "Artifacts directory does not exists or isn't a directory"

    [ -r "${main__create__artifacts}" ] ||
      err::trace "Unable to read artifacts directory"

    artifacts="$(cd "${main__create__artifacts}" &&
                 tar -c . | base64)"
    output+=$'\n'"$(artifact::build "${main__create__artifacts}")"$'\n'

    out::user "dumped artifacts from: ${main__create__artifacts}"
  fi
  if [ "${main__create__secrets}" ]; then
    output+=$'\n'"secret::load '${main__create__secrets}'"$'\n'
    out::user "set secret url to: ${main__create__secrets}"
  fi
  out::info "created core launcher"
  for template in "$@"; do
    [ -r "$template" ] ||
      err::trace "Unable to find template: $template"
    output+="$(<"$template")"$'\n'
    out::info "dumping template: $template"
  done
  output+=$'\ncontext::run\n'
  if ${main__create__compress:-false}; then
    local launcher="#!/bin/bash"$'\n'
    launcher+="POTION_PAYLOAD='$(echo "${output}" | gzip -9 | base64)'"$'\n'
    # shellcheck disable=SC2016
    launcher+='exec bash < <(echo "$POTION_PAYLOAD" | base64 -d | gzip -d)'
    launcher+=$'\n'
    output="$launcher"
  fi
  echo "${output}" > "${main__create__output}"
}

# run action
main::run::opt_artifacts () { main__run__artifacts="$1"; return 2; }
main::run::opt_secrets () { main__run__secrets="$1"; return 2; }
main::run () {
  main::init "in-line"
  if [ "${main__run__artifacts}" ]; then
    [ -d "${main__run__artifacts}" ] ||
      err::trace "Artifacts directory does not exists or isn't a directory"

    [ -r "${main__run__artifacts}" ] ||
      err::trace "Unable to read artifacts directory"

    eval "$(artifact::build "${main__run__artifacts}")"
    out::user "dumped artifacts from: ${main__run__artifacts}"
  fi
  if [ "${main__run__secrets}" ]; then
    secret::load "${main__run__secrets}"
    out::user "loaded secrets from: ${main__run__secrets}"
  fi
  for src in "$@"; do
    include "$src" || err::trace "Unable to load potion file(s): $src"
  done
  context::run
}

# fun: main [arguments]
# txt: function to create random errors and weird behaviour.
main () {
  # if this is a compiled potion, we don't need main
  ${POTION_COMPILED:-false} && main::init && return 0
  
  arg::opt MAIN -q --quiet   main::opt_quiet   'do not output messages'
  arg::opt MAIN -v --verbose main::opt_verbose 'enable verbose mode'
  arg::opt MAIN -d --debug   main::opt_debug   'enable debug mode'
  arg::opt MAIN -p --pretend main::opt_pretend 'do nothing, just pretending'
  arg::opt MAIN -V --version main::opt_version 'show program version number'

  arg::action create main::create 'create new potion from templates'
  arg::param create "infredients+" \
    'URL to the ingredient files to make the potion'
  arg::opt create -o: --output: main::create::opt_output \
    'set path to output potion filename'
  arg::opt create -a: --artifacts: main::create::opt_artifacts \
    'set path to artifacts directory'
  arg::opt create -c  --compress   main::create::opt_compress \
    'create compressed potion (require gzip)'
  arg::opt create -s:  --secrets:   main::create::opt_secrets \
    'set a secret file or URL to store passwords'
  
  arg::action run main::run 'run potion template'
  arg::param run "infredients+" \
    'path to the ingredient files to make the potion'
  arg::opt run -a: --artifacts: main::run::opt_artifacts \
    'set path to artifacts directory'
  arg::opt run -s:  --secrets:   main::run::opt_secrets \
    'set a secret file or URL to store passwords'

  arg::parse "$@"
}
shopt -s expand_aliases
#! /bin/bash
# mod: secret
# txt: The `secret` module allows you to get/set passwords or secret config
#      keys from diferent sources instead of save them in plain text in the
#      potion file.

declare -A _secrets

# fun: secret::load [name=]<name>
# txt: load a secret file
secret::load () {
  local url="${1#name=}"
  case "$url" in
    gpg://*|file+gpg://*) url="${url#*://}"
      eval "$(gpg -d "$url")";;
    *) url="${url#file://}"
       # shellcheck disable=SC1090
       source "$url" || err::trace "Invalid secret file format" ;;
  esac
}

# fun: secret::add [name=]<name> content=<content>
# txt: add new secret with specified content associated with key passed as
#      argument.
secret::add () {
  # shellcheck disable=SC2046
  eval $(std::parse "$@")
  # shellcheck disable=2154
  _secrets["$name"]="$content"
}

# fun: secret <name>
# txt: return the secret text associated with specified name
secret () {
  echo "${_secrets["$1"]}"
}
#! /bin/bash
# mod: refresh
# txt: The `refresh` add functionality to refresh services or other
#      resources.

refresh () {
  local res="$1"; shift

  if std::func "${res}::refresh"; then
    "${res}::refresh" "$@" &&
      res::refreshed "${res}" "$1"
  else
    out::warn "unable to refresh ${res}: cannot found refresh handler"
  fi
}
std::installed 'grep' ||  err::trace 'grep is required but not found'
std::installed 'egrep' ||  err::trace 'egrep is required but not found'
std::installed 'uname' ||  err::trace 'uname is required but not found'
std::installed 'sha1sum' ||  err::trace 'sha1sum is required but not found'
std::installed 'tput' ||  err::trace 'tput is required but not found'
std::installed 'date' ||  err::trace 'date is required but not found'
std::installed 'mkdir' ||  err::trace 'mkdir is required but not found'
std::installed 'blkid' ||  err::trace 'blkid is required but not found'
main "$@"
